--- a/net/minecraft/server/Chunk.java
+++ b/net/minecraft/server/Chunk.java
@@ -51,7 +51,7 @@
     private final Map<BlockPosition, NBTTagCompound> f;
     private final Map<BlockPosition, Chunk.c> g;
     public boolean loaded;
-    public final World world;
+    public final WorldServer world; // CraftBukkit - type
     public final Map<HeightMap.Type, HeightMap> heightMap;
     private final ChunkConverter k;
     public final Map<BlockPosition, TileEntity> tileEntities;
@@ -80,7 +80,7 @@
         this.tileEntities = Maps.newHashMap();
         this.m = Maps.newHashMap();
         this.n = Maps.newHashMap();
-        this.world = world;
+        this.world = (WorldServer) world; // CraftBukkit - type
         this.loc = chunkcoordintpair;
         this.k = chunkconverter;
         HeightMap.Type[] aheightmap_type = HeightMap.Type.values();
@@ -109,8 +109,22 @@
         }
 
         this.o = new ShortList[world.w_()];
+        // CraftBukkit start
+        this.bukkitChunk = new org.bukkit.craftbukkit.CraftChunk(this);
     }
 
+    public org.bukkit.Chunk bukkitChunk;
+    public org.bukkit.Chunk getBukkitChunk() {
+        return bukkitChunk;
+    }
+
+    public boolean mustNotSave;
+    public boolean needsDecoration;
+
+    private static final org.bukkit.craftbukkit.persistence.CraftPersistentDataTypeRegistry DATA_TYPE_REGISTRY = new org.bukkit.craftbukkit.persistence.CraftPersistentDataTypeRegistry();
+    public final org.bukkit.craftbukkit.persistence.CraftPersistentDataContainer persistentDataContainer = new org.bukkit.craftbukkit.persistence.CraftPersistentDataContainer(DATA_TYPE_REGISTRY);
+    // CraftBukkit end
+
     public Chunk(WorldServer worldserver, ProtoChunk protochunk, @Nullable Consumer<Chunk> consumer) {
         this(worldserver, protochunk.getPos(), protochunk.getBiomeIndex(), protochunk.r(), protochunk.p(), protochunk.q(), protochunk.getInhabitedTime(), protochunk.getSections(), consumer);
         Iterator iterator = protochunk.z().values().iterator();
@@ -141,6 +155,7 @@
 
         this.b(protochunk.t());
         this.r = true;
+        this.needsDecoration = true; // CraftBukkit
     }
 
     @Override
@@ -235,9 +250,16 @@
         }
     }
 
+    // CraftBukkit start
     @Nullable
     @Override
     public IBlockData setType(BlockPosition blockposition, IBlockData iblockdata, boolean flag) {
+        return this.setType(blockposition, iblockdata, flag, true);
+    }
+
+    @Nullable
+    public IBlockData setType(BlockPosition blockposition, IBlockData iblockdata, boolean flag, boolean doPlace) {
+        // CraftBukkit end
         int i = blockposition.getY();
         int j = this.e(i);
         ChunkSection chunksection = this.sections[j];
@@ -283,7 +305,8 @@
             if (!chunksection.getType(k, l, i1).a(block)) {
                 return null;
             } else {
-                if (!this.world.isClientSide) {
+                // CraftBukkit - Don't place while processing the BlockPlaceEvent, unless it's a BlockContainer. Prevents blocks such as TNT from activating when cancelled.
+                if (!this.world.isClientSide && doPlace && (!this.world.captureBlockStates || block instanceof BlockTileEntity)) {
                     iblockdata.onPlace(this.world, blockposition, iblockdata1, flag);
                 }
 
@@ -341,7 +364,17 @@
 
     @Nullable
     public TileEntity a(BlockPosition blockposition, Chunk.b chunk_b) {
-        TileEntity tileentity = (TileEntity) this.tileEntities.get(blockposition);
+        // CraftBukkit start
+        if (world.capturedTileEntities.containsKey(blockposition)) {
+            return world.capturedTileEntities.get(blockposition);
+        }
+        // CraftBukkit end
+        // CraftBukkit start
+        TileEntity tileentity = world.capturedTileEntities.get(blockposition);
+        if (tileentity == null) {
+            tileentity = (TileEntity) this.tileEntities.get(blockposition);
+        }
+        // CraftBukkit end
 
         if (tileentity == null) {
             NBTTagCompound nbttagcompound = (NBTTagCompound) this.f.remove(blockposition);
@@ -399,6 +432,13 @@
                 tileentity1.ap_();
             }
 
+            // CraftBukkit start
+        } else {
+            System.out.println("Attempted to place a tile entity (" + tileentity + ") at " + tileentity.position.getX() + "," + tileentity.position.getY() + "," + tileentity.position.getZ()
+                + " (" + getType(blockposition) + ") where there was no entity tile!");
+            System.out.println("Chunk coordinates: " + (this.loc.x * 16) + "," + (this.loc.z * 16));
+            new Exception().printStackTrace();
+            // CraftBukkit end
         }
     }
 
@@ -458,6 +498,50 @@
 
     }
 
+    // CraftBukkit start
+    public void loadCallback() {
+        org.bukkit.Server server = this.world.getServer();
+        if (server != null) {
+            /*
+             * If it's a new world, the first few chunks are generated inside
+             * the World constructor. We can't reliably alter that, so we have
+             * no way of creating a CraftWorld/CraftServer at that point.
+             */
+            server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(this.bukkitChunk, this.needsDecoration));
+
+            if (this.needsDecoration) {
+                this.needsDecoration = false;
+                java.util.Random random = new java.util.Random();
+                random.setSeed(world.getSeed());
+                long xRand = random.nextLong() / 2L * 2L + 1L;
+                long zRand = random.nextLong() / 2L * 2L + 1L;
+                random.setSeed((long) this.loc.x * xRand + (long) this.loc.z * zRand ^ world.getSeed());
+
+                org.bukkit.World world = this.world.getWorld();
+                if (world != null) {
+                    this.world.populating = true;
+                    try {
+                        for (org.bukkit.generator.BlockPopulator populator : world.getPopulators()) {
+                            populator.populate(world, random, bukkitChunk);
+                        }
+                    } finally {
+                        this.world.populating = false;
+                    }
+                }
+                server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkPopulateEvent(bukkitChunk));
+            }
+        }
+    }
+
+    public void unloadCallback() {
+        org.bukkit.Server server = this.world.getServer();
+        org.bukkit.event.world.ChunkUnloadEvent unloadEvent = new org.bukkit.event.world.ChunkUnloadEvent(this.bukkitChunk, this.isNeedsSaving());
+        server.getPluginManager().callEvent(unloadEvent);
+        // note: saving can be prevented, but not forced if no saving is actually required
+        this.mustNotSave = !unloadEvent.isSaveChunk();
+    }
+    // CraftBukkit end
+
     public void markDirty() {
         this.r = true;
     }
@@ -527,7 +611,7 @@
 
     @Override
     public boolean isNeedsSaving() {
-        return this.r;
+        return this.r && !this.mustNotSave; // CraftBukkit
     }
 
     @Nullable
@@ -658,7 +742,7 @@
 
     public void C() {
         if (this.p instanceof ProtoChunkTickList) {
-            ((ProtoChunkTickList) this.p).a(this.world.getBlockTickList(), (blockposition) -> {
+            ((ProtoChunkTickList<Block>) this.p).a(this.world.getBlockTickList(), (blockposition) -> { // CraftBukkit - decompile error
                 return this.getType(blockposition).getBlock();
             });
             this.p = TickListEmpty.b();
@@ -668,7 +752,7 @@
         }
 
         if (this.q instanceof ProtoChunkTickList) {
-            ((ProtoChunkTickList) this.q).a(this.world.getFluidTickList(), (blockposition) -> {
+            ((ProtoChunkTickList<FluidType>) this.q).a(this.world.getFluidTickList(), (blockposition) -> { // CraftBukkit - decompile error
                 return this.getFluid(blockposition).getType();
             });
             this.q = TickListEmpty.b();
@@ -680,12 +764,12 @@
     }
 
     public void a(WorldServer worldserver) {
-        if (this.p == TickListEmpty.b()) {
+        if (this.p == TickListEmpty.<Block>b()) { // CraftBukkit - decompile error
             this.p = new TickListChunk<>(IRegistry.BLOCK::getKey, worldserver.getBlockTickList().a(this.loc, true, false), worldserver.getTime());
             this.setNeedsSaving(true);
         }
 
-        if (this.q == TickListEmpty.b()) {
+        if (this.q == TickListEmpty.<FluidType>b()) { // CraftBukkit - decompile error
             this.q = new TickListChunk<>(IRegistry.FLUID::getKey, worldserver.getFluidTickList().a(this.loc, true, false), worldserver.getTime());
             this.setNeedsSaving(true);
         }
@@ -736,7 +820,7 @@
 
     private <T extends TileEntity> void d(T t0) {
         IBlockData iblockdata = t0.getBlock();
-        TileEntityTicker<T> tileentityticker = iblockdata.a(this.world, t0.getTileType());
+        TileEntityTicker<T> tileentityticker = (TileEntityTicker<T>) iblockdata.a(this.world, t0.getTileType()); // CraftBukkit - decompile error
 
         if (tileentityticker == null) {
             this.m(t0.getPosition());
@@ -808,7 +892,7 @@
         private boolean d;
 
         private EnumTileEntityState(TileEntity tileentity, TileEntityTicker tileentityticker) {
-            this.QUEUED = tileentity;
+            this.QUEUED = (T) tileentity; // CraftBukkit - decompile error
             this.CHECK = tileentityticker;
         }
 
